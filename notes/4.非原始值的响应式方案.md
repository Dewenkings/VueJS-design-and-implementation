# 非原始值的响应式方案

## 理解 Proxy 和 Reflect

什么是 Proxy？简单地说，使用 Proxy 可以创建一个代理对象。它能够实现对**其他对象（也就是非原始值）**的代理。

代理指的是对一个对象的**基本语义**的代理；Proxy 允许我们拦截并重新定义对一个对象的基本操作。

什么是基本语义？给出一个对象 obj，可以对它进行一些操作，例如读取属性值、设置属性值：

```js
obj.foo // 读取属性 foo 的值
obj.foo++ // 读取和设置属性 foo 的值
```

这种就属于基本语义的操作，即基本操作。既然是基本操作，那么它就可以使用 Proxy 拦截：

```js
const p = new Proxy(obj, {
  // 拦截读取属性操作
	get () { /* ... */ },
  // 拦截设置属性操作
  set () { /* ... */ }
})
```

在 JavaScript 中，万物皆对象。例如一个函数也是一个对象，所以调用函数也是对一个对象的基本操作：

```js
const fn = name => console.log(`我是：${name}`)
fn() // 调用函数是对对象的基本操作
```

因此我们可以用 Proxy 来拦截函数的调用操作，这里使用 apply 拦截函数的调用：

```js
const p2 = new Proxy(fn, {
  apply (traget, thisArg, argArray) {
    target.call(thisArg, ...argArray)
  }
})

p2('zhangsan') // 输出：'我是：zhangsan'
```

上面的两个例子说明了什么是基本操作。Proxy 只能拦截对一个对象的基本操作。那么什么是非基本操作呢？其实调用对象下的方法就是一个典型的非基本操作，我们称它为**复合操作：**

```js
obj.fn()
```

它由两个基本语义组成：get 和 apply。先通过 get 操作得到 obj.fn 属性，然后再通过  apply 调用 。

理解了 Proxy，我们再讨论 Reflect。Reflect 是一个全局对象，其下有许多方法，例如：

```js
Reflect.get()
Reflect.set()
Reflect.apply()
// ...
```

任何在 Proxy 的拦截器中能够找到的方法，都能够在 Reflect 中找到同名函数，那么这些函数的作用是什么呢？拿 Reflect.get 函数来说，它的功能就是提供了访问一个对象属性的默认行为：

```js
const obj = { foo: 1 }

console.log(obj.foo) // 1
console.log(Reflect.get(obj, 'foo')) // 1
```

这两种操作是等价的。Reflect 还能接收第三个参数，即指定接收者 receiver，可以理解为函数调用过程中的 this，例如：

```js
const obj = { foo: 1 }
console.log(Reflect.get(obj, 'foo', { foo: 2 })) // 2
```

这上面的代码中，我们指定了 `{ foo: 2 }` 这个对象为 receiver，这时读取到的值是 receiver 对象的 foo 属性值。

实际上，Reflect 上面的方法还有很多其他方面的意义，但这里只关心 receiver 这一点，因为它与响应式数据的实现密切相关。为了说明问题，我们回顾一下之前实现的响应式的代码：

```js
const data = { foo: 1 }

// 对原始数据进行代理
const obj = new Proxy(data, {
  // 拦截读取操作
  get (target, key) {
    track(target, key)

    // 返回属性值
    return target[key]
  },

  // 拦截设置操作
  set (target, key, value) {
    // 设置属性值
    target[key] = value
    
    trigger(target, key)

    // 返回 true 表示设置操作成功
    return true
  }
})
```

我们之前都是利用原始对象 target 来完成对属性的读取和设置操作的，其中原始对象 target 就是上述代码中的 data 对象。

那么这段代码有什么问题呢？我们借助 effect 让问题暴露出来。

首先我们修改一下 data 对象，为它添加 bar 属性：

```js
const data = {
  foo: 1,
  get bar () {
    return this.foo
  }
}
```

然后我们在 effect 副作用函数中通过代理对象 obj  访问 bar 属性：

```js
effect(() => console.log(obj.bar)) // 1
```

当我们尝试修改 `obj.foo` 的值时：

```js
obj.foo++
```

副作用函数并没有重新执行，问题出在哪呢？

实际上，问题就出在 bar 属性的访问器函数 getter 里，它里面的 this 指向的是谁？

我们在拦截器里面通过 ` target[key]` 来处理，相当于 `data.bar` 。因此，当我们使用 `obj.bar` 访问 bar 属性时，它的 getter 函数内的this 指向的其实是原始对象 data，这说明我们最终访问的其实是 data.foo。

很显然，在副作用函数内通过原始对象访问它的某个属性是不会建立响应联系的，这相当于：

```js
effecet(() => {
  // data 是原始数据，不是代理对象，这样的访问不能够建立响应联系
  data.foo
})
```

因为这样做不会建立响应联系，所以出现了无法触发响应的问题。那么如何解决这个问题呢？这时 `Reflect.get()` 函数就派对上用场了：

```js
const obj = new Proxy(data, {
  // 拦截读取操作，接收第三个参数 receiver
  get (target, key, receiver) {
    track(target, key)
    // 使用 Reflect.get() 返回读取到的属性值
    return Reflect.get(target, key, receiver)
  },
  // ...
})
```

`get()` 拦截器它的第三个参数 receiver 指的是谁在读取属性，例如：

```js
obj.foo
```

那么这个 receiver 就是 obj，你可以把它简单地理解为函数调用中的 this。接着关键的一步发生，我们使用 `Reflect.get(target, key, receiver)` 代替之前的 `taret[key]`，这里的关键点就是第三个参数 receiver。我们已经知道它就是代理对象 obj，所以访问器属性 bar 的 getter() 函数内的 this 就指向了代理对象 obj。

```js
const data = {
  foo: 1,
  get bar () {
    // 现在这里的 this 是代理对象 obj
    return this.foo
  }
}
```

可以看到，this 由原始对象 data 变成了代理对象 obj。很显然，这会在副作用函数与响应式数据之间建立响应联系，从而达到依赖收集的效果。如果此时再对 obj.foo 进行自增操作，会发现已经通解触发副作用函数重新执行了。

正是基于上述原因，后面的讲解将统一使用 Reflect.* 方法。

## JavaScript 对象及 Proxy 的工作原理

什么是对象？

根据 ECMAScript 规范，在 JavaScript 中有两种对象，其中一种对作**常规对象（ordinary object）**，另一种叫作**异质对象（exotic object）**。这两种对象包含了 JavaScript 世界中的所有对象。任何不属于常规对象的对象都是异质对象。

那么什么是常规对象、什么是异质对象呢？这需要我们先了解对象的内部方法和内部槽。

我们知道，在 JavaScript 中，函数其实也是对象。假设给出一个对象 obj，如何区分它是普通对象还是函数呢？

实际上，在 JavaScript 中，对象的实际语义是由对象的**内部方法（internal method）**指定的。所谓内部方法，指的是当我们对一个对象进行操作时，在引擎内部调用的方法，这些方法对于 JavaScript 使用者来说是不可见的。

举个例子，当我们访问对象的属性时：

```js
obj.foo
```

引擎内部会调用 `[[Get]]` 这个内部方法来读取属性值。这里补充说明一下，在 ECMAScript 规范中使用了 `[[xxx]]` 来代表内部方法或内部槽。当然，一个对象不仅部署了 `[[Get]]` 这个内部方法，下表列出了规范要求的所有必要的内部方法：

| 内部方法                | 签名                                               | 描述                                                         |
| ----------------------- | -------------------------------------------------- | ------------------------------------------------------------ |
| `[[GetPrototypeOf]]`    | `() -> Object | Null`                              | 查明为该对象提供继续属性的对象 null 代表没有继承属性         |
| `[[SetPrototypeOf]]`    | `(Object | Null) -> Boolean`                       | 将该对象与提供继续属性的另一个对象相关联。传递 null 表示没有继承属性，返回 true 表示操作成功完成，返回 false 表示操作失败 |
| `[[IsExtensible]]`      | `() -> Boolean`                                    | 查明是否允许向该对象添加其他属性                             |
| `[[PreventExtensions]]` | `() -> Boolean`                                    | 控制能否向该对象添加新属性。如果操作成功则返回 true，如果操作失败则返回 false |
| `[[GetOwnProperty]]`    | `(propertyKey) -> Undefined | Property Descriptor` | 返回该对象自身属性的描述符，其键为 propertyKey，如果不存在这样的属性，则返回 undefined |
| `[[DefineOwnProperty]]` | `(propertyKey, PropertyDescriptor) -> Boolean`     | 创建或更改自己的属性，其键为 propertyKey，以具有由 PropertyDescriptor 描述的状态。如果该属性已成功创建或更新，则返回 true；如果无法创建或更新该属性，则返回 false |
| `[[HasProperty]]`       | `(propertyKey) -> Boolean`                         | 返回一个布尔值，指示该对象是否已经拥有键为 propertyKey 的自己的或继承的属性 |
| `[[Get]]`               | `(propertyKey, Receiver) -> any`                   | 从该对象返回键为 propertyKey 的属性的值。如果必须运行 ECMAScript 代码来检索属性值，则在运行代码时使用 Receiver 作为 this 值 |
| `[[Set]]`               | `(propertyKey, value, Receiver) -> Boolean`        | 将键值为 propertyKey 的属性的值设置为 value。如果必须运行 ECMAScript 代码来设置属性值，则在运行代码时使用Receiver 作为 this 值。如果成功设置了属性值，则返回 true，如果无法设置，则返回 false |
| `[[Delete]]`            | `(propertyKey) -> Boolean`                         | 从对象中删除属于自身键为 propertyKey 的属性。如果该属性未被删除并且仍然存在，则返回 false；如果该属性已被删除或不存在，则返回 true |
| `[[OwnPropertyKeys]]`   | `() -> List of propertyKey`                        | 返回一个 List，其元素都是对象自身的属性键                    |

由上表（表1）可知，一个对象必须部署 11 个必要的内部方法。除了上表所列的内部方法之外，还有两个额外的必要内部方法：`[[Call]]` 和 `[[Construct]]`，如下表（表2）

| 内部方法        | 签名                                | 描述                                                         |
| --------------- | ----------------------------------- | ------------------------------------------------------------ |
| `[[Call]]`      | `(any, a List of any) -> any`       | 将运行代码与 this 对象关联。由函数调用触发。该内部方法的参数是一个 this 值和参数列表 |
| `[[Construct]]` | `(a List of any, Object) -> Object` | 创建一个对象。通过 new 运算符或 super 调用触发。该内部方法的第一个参数是一个 List，该  List 的元素是构造函数调用或 super 调用的参数，第二个参数是最初应用 new 运算符的对象。实现该内部方法的对象称为构造函数 |

如果一个对象需要作为函数调用，那么这个对象就必须部署内部方法`[[Call]]`。现在我们可以回答前面的问题了：如何区分一个对象是普通对象还是函数？一个对象在什么情况下作为函数调用呢？答案是，通过内部方法和内部槽来区分对象，例如函数对象会部署内部方法`[[Call]]`，而普通对象则不会。

内部方法具有金矿性，这是什么意思呢？这类似于面向对象里多态的概念。意思是说**不同类型的对象可能部署了相同的内部方法，却具有不同的逻辑**。例如普通对象和 Proxy 都部署了 `[[Get]]` 这个内部方法，但它们的逻辑是不同的，普通对象部署的 `[[Get]]` 内部方法是由 ECMA 规范的 10.1.8 节定义的，而 Proxy 对象部署的 `[[Get]]` 内部方法是由 ECMA 规范的 10.5.8 节来定义的。

了解了内部方法，就可以触发什么是常规对象，什么是异质对象了。

满足以下条件的对象就是**常规对象**：

+ 对于表1列出的内部方法，必须使用 ECMA 规范 10.1.x 节给出的定义实现；
+ 对于内部方法`[[Call]]`，必须使用 ECMA 规范 10.2.1 节给出的定义实现；
+ 对于内部方法`[[Construct]]`，必须使用 ECMA 规范 10.2.2 节给出的定义实现。

而所有不符合这三点要求的对象都是异质对象。例如 Proxy 对象的内部方法 `[[Get]]` 没有使用 ECMA 规范的 10.1.8 节给出的定义实现，所以 Proxy 是一个异质对象。

现在我们对 JavaScript 中的对象有了更加深入的理解。接下来，我们就具体看看 Proxy 对象。

```js
const p = new Proxy(obj, { /* ... */ })
p.foo
```

实际上，引擎会调用部署在对象 p 上的内部方法 `[[Get]]` 。到这一步，其实代理对象和普通对象没有太大的区别。它们的区别在于对于内部方法 `[[Get]]` 的实现，这里就体现了内部方法的多态性，即不同的对象部署相同的内部方法，但它们的行为可能不到。具体的不同体现在，如果创建代理对象时没有指定对应的拦截函数，例如没有指定 `get()` 拦截函数，那么当我们通过代理对象访问属性值时，代码对象的内部方法 `[[Get]]` 会调用原始对象的内部方法 `[[Get]]` 来获取属性值，这其实就是代理透明性质。

现在相信你已经明白了，创建代理对象时指定的拦截函数，实际上是用来自定义代理对象本身内部方法和行为的，而不是用来指定被代理对象方法和行为的。

表3列出了 Proxy 对象部署的内部方法以及用来自定义内部方法和行为的拦截函数名称：

| 内部方法                | 处理器函数               |
| ----------------------- | ------------------------ |
| `[[GetPropertyOf]]`     | getPropertyOf            |
| `[[SetPropertyOf]]`     | setPropertyOf            |
| `[[IsExtensible]]`      | isExtensible             |
| `[[PreventExtensions]]` | preventExtensions        |
| `[[GetOwnProperty]]`    | getOwnPropertyDescriptor |
| `[[DefineOwnProperty]]` | defineProperty           |
| `[[HasProperty]]`       | has                      |
| `[[Get]]`               | get                      |
| `[[Set]]`               | set                      |
| `[[Delete]]`            | deleteProperty           |
| `[[OwnPropertyKeys]]`   | ownKeys                  |
| `[[Call]]`              | apply                    |
| `[[Construct]]`         | construct                |

其中 `[[Call]]` 和 `[[Construct]]` 这两个内部方法只有当被代理的对象是函数和构造函数时才会部署。

由表3可知，当我们要拦截删除属性操作时，可以使用 `deleteProperty` 拦截函数：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, {
  deleteProperty (target, key) {
    return Reflect.deleteProperty(target, key)
  }
})

console.log(p.foo) // 1
delete p.foo
console.log(p.foo) // undefined
```

## 如何代理 Object

前面我们使用 get 拦截函数去拦截对属性的读取操作。但在响应系统中，“读取”是一个很宽泛的概念，例如使用 in 操作符检查对象上是否存在给定的 key 也属于“读取”操作，如下代码所示：

```js
effect(() => {
  'foo' in obj
})
```

这本质上也是在进行“读取”操作。响应系统应该拦截一切读取操作，以便当数据变化时能够做出正确的响应。下面列出了对一个普通对象的所有可能读取操作：

+ 访问属性：`obj.foo`；
+ 判断对象或原型上是否存在给定的 key：`key in obj`；
+ 使用 `for...in` 循环遍历对象：`for (const key in obj)`。

接下来，我们逐步讨论如何拦截这些读取操作。首先是对于属性的读取，例如 `obj.foo`，我们知道这可以通过 `get()` 拦截函数实现：

```js
const obj = { foo: 1 }

const p = new Proxy(obj, {
  get (target, key, receiver) {
    track(traget, key)
    return Reflect.get(target, key, receiver)
  }
})
```

对于 in 操作符，应该如何拦截呢？我们可以先查看表3，尝试寻找与 in 操作符对应的拦截函数，但是表3中没有与   in 操作符相关的内容。怎么办呢？这时我们就需要查看关于 in 操作符的相关规范。在 ECMA-262 规范的 13.10.1 节中，明确定义了 in 操作符的运行时逻辑。它的第6步说明 in 操作符的 运行结果是通过调用一个叫作 HasProperty 的抽象方法得到的。关于 HasProperty 抽象方法，可以在 ECMA-262 规范的 7.3.11 节中找到，在第3步中，指出 HasProperty 抽象方法的返回值是通过调用对象的内部方法 `[[HasProperty]]` 得到的。而这个内部方法我们可以在表3中找到，它对应的拦截函数是 `has()`，因此我们可以通过 `has()` 拦截函数实现对 in 操作符的代理：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, {
  get (target, key, receiver) {
    track(traget, key)
    return Reflect.has(target, key, receiver)
  }
})
```

再来看看如何拦截 `for...in` 循环，我们通过上述的查找方式，在 ECMA-262 规范的 14.7.5.6 节中找到 for...in 的头部执行规则，其第6点的第 c 子步骤表明它依赖一个 `EnumerateObjectProperties` 这个抽象方法。规范的 14.7.5.9 节中给出了满足该抽象方法的示例实现：

```js
function * EnumerateObjectProperties (obj) {
  const visited = new Set()

  for (const key of Reflect.ownKeys(obj)) {
    if (typeof key === 'symbol') {
      continue
    }
    
    const desc = Reflect.getOwnPropertyDescriptor(obj, key)
    
    if (desc) {
			visited.add(key)
      if (desc.enumerable) {
				yield key
      }
    }
	}
  
  const proto = Reflect.getPrototypeOf(obj)
  if (proto === null) {
    return
  }
  
  for (const protoKey of EnumerateObjectProperties(proto)) {
    if (!visited.has(protoKey)) {
			yield protoKey
    }
  }
}
```

可以看到关键点在于使用 Reflect.ownKeys(obj) 来获取只属于对象自身拥有的键。有了这个线索，如何拦截 `for...in` 循环的答案已经很明显了，我们可以使用 `ownKeys()` 拦截函数来拦截 Reflect.ownKeys 操作：

```js
const obj = { foo: 1 }
const ITERATE_KEY = Symbol()

cosnt p = new Proxy(obj, {
  ownKeys (target) {
		// 将副作用函数与 ITERATE_KEY 关联
    track(target, ITERATE_KEY)
    return Reflect.ownKeys(target)
  }
})
```

如上面的代码所示，拦截 ownKeys 操作即可间接拦截 for...in 循环。

我们在使用 `track()` 函数进行追踪的时候，将 ITERATE_KEY 作为追踪的 key，这是因为 `ownKeys()` 拦截函数与 `get()/set()` 拦截函数不同，我们无法拿到 key，只能拿到目标对象 target，所以我们需要构造一个唯一的 key 作为标识，即 ITERATE_KEY。

相应地，在触发响应时也应该触发它才行：

```js
trigger(target, ITERATE_KEY)
```

但是在什么情况下，对数据的操作需要触发与 ITERATE_KEY 相关联的副作用函数重新执行呢？我们用一段代码来说明：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, { /* ... */ })

effect(() => {
  for (const key in p) {
    console.log(key)
  }
})
p.bar = 2
```

由于对象 p 原本只有 foo 属性，因此循环只会执行一些。当我们为它添加了新的属性 bar，循环就会由一次变成两次。也就是说，当为对象添加新属性时会对 `for...in` 循环产生影响，所以需要触发与 ITERATE_KEY 相关联的副作用函数重新执行。当然我们之前的实现还做不到这一点。

我们先看下 `set()` 拦截函数的实现：

```js
const p = new Proxy(obj, {
  set (target, key, newVal, receiver) {
    const res = Reflect.set(target, key, newVal, receiver)
    trigger(target, key)
    
    return res
  },
  // ...
})
```

当为对象 p 添加新的 bar 属性时，会触发 `set()` 拦截函数执行。此时接收到的 key 就是字符串 'bar'，因此 `trigger()` 函数也只会触发了与 'bar' 相关联的副作用函数重新执行。

但根据前文介绍，我们知道 for...in 循环是在副作用函数与 ITERATE_KEY 之间建立联系，这和 'bar' 无关，因此当我们尝试执行 p.bar = 2 操作时，并不能正确地触发响应。

弄清楚了问题在哪里，解决方案也就随之而来了。当添加属性时，我们将那些与 ITERATE_KEY 相关联的副作用函数也取出来执行就可以了：

```js
function trigger (target, key) {
  // 根据 target 从 bucket 中取出所有的 depsMap
  const depsMap = bucket.get(target)

  if (!depsMap) return true

  // 根据 key 从 depsMap 中取出所有的副作用函数
  const effects = depsMap.get(key)
  
  // 根据 ITERATE_KEY 从 depsMap 中取出所有的副作用函数
  const iterateEffects = depsMap.get(ITERATE_KEY)

  // effects && effects.forEach(fn => fn())

  // 用一个新的 Set 来完成 forEach 操作，防止添加时进入死循环
  const effectsToRun = new Set()

  effects && effects.forEach(effectFn => {
    // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  
  iterateEffects && iterateEffects.forEach(effectFn => {
    // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  
  effectsToRun.forEach(effectFn => {
    // 如果该副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
    if (effectFn.options.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      // 否则直接执行副作用函数
      effectFn()
    }
  })
}
```

如上代码所示，当 `trigger()` 函数执行时，除了把那些直接与具体操作的 key 相关联的副作用函数取出来执行之外，还要把那么与 ITERATE_KEY 相关联的副作用函数取出来执行。

对于添加新的属性来说，这样做没什么问题，但是修改已有的属性，那么问题就来了：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, { /* ... */ })

effect(() => {
  for (const key in p) {
    console.log(key)
  }
})
p.foo = 2
```

与添加新属性不同，修改属性 对于 for...in 循环来说都只会循环一次。所以在这种情况下，我们不需要触发副作用函数重新执行，否则会造成不必要的性能开销。然而无论是添加新属性，还是修改已有的属性，我们都是通过其基本语义 `[[Set]]` ，也就是通过 `set()` 拦截函数来实现拦截的。

所以我们需要在 `set()` 拦截函数内部判断到底是新增还是修改属性：

```js
const p = new Proxy(obj, {
  set (target, key, newValue, receiver) {
		// 如果属性不存在，则说明是在新增属性，否则是修改属性
    const type = Object.prototyp.hasOwnProperty.call(target, key)
    	? 'SET'
    	: 'ADD'
    
    const res = Reflect.set(target, key, newValue, receiver)
    
    // 将 type 作为第三个参数传递给 trigger() 函数
    trigger(target, key, type)
    
    return res
  },
  // ...
})
```

那么我们就可以在 `trigger()` 函数内通过 type 来区分当前的操作类型，并且只有当 type 为 'ADD' 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行，这样就避免了不必要的性能开销：

```js
function trigger (target, key, type) {
  // 根据 target 从 bucket 中取出所有的 depsMap
  const depsMap = bucket.get(target)

  if (!depsMap) return true

  // 根据 key 从 depsMap 中取出所有的副作用函数
  const effects = depsMap.get(key)
  
  // 根据 ITERATE_KEY 从 depsMap 中取出所有的副作用函数
  const iterateEffects = depsMap.get(ITERATE_KEY)

  // effects && effects.forEach(fn => fn())

  // 用一个新的 Set 来完成 forEach 操作，防止添加时进入死循环
  const effectsToRun = new Set()

  effects && effects.forEach(effectFn => {
    // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  
  // 只有当操作类型为 'ADD' 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行
  if (type === 'ADD') {
    iterateEffects && iterateEffects.forEach(effectFn => {
      // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn)
      }
    })
  }
  
  effectsToRun.forEach(effectFn => {
    // 如果该副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
    if (effectFn.options.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      // 否则直接执行副作用函数
      effectFn()
    }
  })
}
```

通常我们会将操作类型封装为一个枚举值，这样无论是对后期代码的维护，还是对代码的清晰度，都是非常有帮助的：

```js
const TriggerType = {
  ADD: 'ADD',
  SET: 'SET'
}
```

关于对象的代理，还剩下最后一项工作需要做，即删除属性操作的代理：

```js
delete p.foo
```

在 ECMA-262 规范中的 13.5.1.2 节的第5步中的 d 子步骤中指出 delete 操作符依赖 `[[Delete]]` 内部方法。查看表3可知，该内部方法可以使用 deleteProperty 拦截：

```js
const p = new Proxy(obj, {
  deleteProperty (target, key) {
    // 检查被操作的属性是否是对象自己的属性
    const hadKey = Object.prototype.hasOwnProperty.call(target, key)
    
    const res = Reflect.deleteProperty(target, key)
    
    if (res && hadKey) {
      // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新
      trigger(target, key, 'DELETE')
    }
    
    return res
  }
})
```

需要注意的时，在调用 `trigger()` 函数时，我们传递了新的操作类型 'DELETE'。由于删除操作会影响 for...in 循环的次数，因此操作类型为 'DELETE' 时，我们也应该触发那些与 ITERATE_KEY 相关联的副作用函数重新执行：

```js
function trigger (target, key, type) {
  // 根据 target 从 bucket 中取出所有的 depsMap
  const depsMap = bucket.get(target)

  if (!depsMap) return true

  // 根据 key 从 depsMap 中取出所有的副作用函数
  const effects = depsMap.get(key)
  
  // 根据 ITERATE_KEY 从 depsMap 中取出所有的副作用函数
  const iterateEffects = depsMap.get(ITERATE_KEY)

  // effects && effects.forEach(fn => fn())

  // 用一个新的 Set 来完成 forEach 操作，防止添加时进入死循环
  const effectsToRun = new Set()

  effects && effects.forEach(effectFn => {
    // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
    if (effectFn !== activeEffect) {
      effectsToRun.add(effectFn)
    }
  })
  
  // 只有当操作类型为 'ADD' 或 'DELETE' 时，才触发与 ITERATE_KEY 相关联的副作用函数重新执行
  if (
    type === 'ADD' ||
    type === 'DELETE'
  ) {
    iterateEffects && iterateEffects.forEach(effectFn => {
      // 如果 trigger 触发执行副作用函数与当前正在执行的副作用函数相同，则不触发
      if (effectFn !== activeEffect) {
        effectsToRun.add(effectFn)
      }
    })
  }
  
  effectsToRun.forEach(effectFn => {
    // 如果该副作用函数存在调度器，则调用该调度器，并将副作用函数作为参数传递
    if (effectFn.options.scheduler) {
      effectFn.options.scheduler(effectFn)
    } else {
      // 否则直接执行副作用函数
      effectFn()
    }
  })
}
```

## 合理地触发响应

当值没有发生变化时，应该不需要触发响应：

```js
const obj = { foo: 1 }
const p = new Proxy(obj, { /* ... */ })

effect(() => {
  console.log(p.foo)
})

p.foo = 1 // 设置了值，但没有变化
```

所以我们需要修改 `set()` 拦截函数的代码，在调用 `trigger()` 函数触发响应之前，需要检查值是否真的发生了变化：

```js
const p = new Proxy(obj, {
  set (target, key, newValue, receiver) {
		// 先获取旧值
    const oldValue = target[key]
    
    const type = Object.prototyp.hasOwnProperty.call(target, key)
    	? 'SET'
    	: 'ADD'
    
    const res = Reflect.set(target, key, newValue, receiver)
    
    // 比较新值与旧值，只有当不全等的时候才触发响应
    if (oldValue !== newValue) {
      // 将 type 作为第三个参数传递给 trigger() 函数
      trigger(target, key, type)
    }
    
    return res
  }
})
```

然后，仅仅是进行全等比较是有缺陷的，这体现在对 NaN 的处理上。我们知道 NaN 与 NaN 的全等比较总会得到 false。

为了解决这个问题，我们需要加一个条件，需要确保它们不是 NaN：

```js
const p = new Proxy(obj, {
  set (target, key, newVal, receiver) {
		// 先获取旧值
    const oldVal = target[key]
    
    const type = Object.prototyp.hasOwnProperty.call(target, key)
    	? 'SET'
    	: 'ADD'
    
    const res = Reflect.set(target, key, newVal, receiver)
    
    // 比较新值与旧值，只有当不全等的时候
    // 并且它们都不是 NaN 时才触发响应
    if (
      oldVal !== newVal &&
      (
      	oldVal === oldVal ||
        newVal === newVal
      )
    ) {
      // 将 type 作为第三个参数传递给 trigger() 函数
      trigger(target, key, type)
    }
    
    return res
  }
})
```

这样我们就解决了 NaN 的问题。

但想要合理地触发响应，仅仅处理关于 NaN 问题还不够。接下来，我们讨论一种从原型上继承属性的情况。为了后续讲解方便，我们需要封装一个 `reactive()` 函数，该函数接收一个对象作为参数，并返回为其创建的响应式数据：

```js
function reactive (obj) {
  return new Proxy(obj, {
    // 拦截读取操作
    get (target, key, receiver) {
      track(target, key)
  
      // 返回属性值
      return Reflect.get(target, key, receiver)
    },
  
    // 拦截设置操作
    set (target, key, newVal, receiver) {
      // 先获取旧值
      const oldVal = target[key]

      // 如果属性不存在，则说明是在新增属性
      // 否则是修改属性
      const type = Object.prototype.hasOwnProperty.call(target, key)
        ? TriggerType.SET
        : TriggerType.ADD

      // 设置属性值
      const res = Reflect.set(target, key, newVal, receiver)
      
      // 比较新值与旧值，只有当不全等的时候
      // 并且它们都不是 NaN 时才触发响应
      if (
        oldVal !== newVal &&
        (
          oldVal === oldVal ||
          newVal === newVal
        )
      ) {
        // 将 type 作为第三个参数传递给 trigger() 函数
        trigger(target, key, type)
      }
  
      return res
    },

    ownKeys (target) {
      // 将副作用函数与 ITERATE_KEY 关联
      track(target, ITERATE_KEY)
      return Reflect.ownKeys(target)
    },

    deleteProperty (target, key) {
      // 检查被操作的属性是否是对象自己的属性
      const hadKey = Object.prototype.hasOwnProperty.call(target, key)
      
      const res = Reflect.deleteProperty(target, key)
      
      if (res && hadKey) {
        // 只有当被删除的属性是对象自己的属性并且成功删除时，才触发更新
        trigger(target, key, 'DELETE')
      }
      
      return res
    },

    // 拦截函数调用
    apply (target, thisArg, argsList) {
      Reflect.apply(target, thisArg, argsList)
    }
  })
}
```

