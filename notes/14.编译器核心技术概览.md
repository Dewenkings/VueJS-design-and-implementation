# 编译器核心技术概览

作为前端工程师，我们应用编译技术的场景通常是：表格、报表中的自定义公式计算器，设计一种领域特定语言（DSL）等。其中，实现公式计算器甚至只涉及编译前端技术，而领域特定语言根据其具体使用场景和目标平台不同，难度会有所不同。Vue.js 的模板和 JSX 都属于特定语言，它们实现难度属于中、低级别，只要掌握基本的编译技术理论即可实现这些功能。

## 模板 DSL 的编译器

编译器其实只是一段程序，它用来将 “一种语言 A” 翻译成 “另一种语言 B”。其中，语言 A 通常叫作**源代码（source code）**，语言 B 通常叫作**目标代码（object code 或 target code）。**编译器将源代码翻译为目标代码的过程叫作编译（compile）。完整的编译过程通常包括词法分析、语法分析、语义分析、中间代码生成、优化、目标代码生成等步骤，如下图所示：

![完整的编译过程](E:\www\笔记\VueJS-design-and-implementation\imgs\编译器核心\1.png)

可以看到，整个编译过程分为编译前端和编译后端。编译前端包含词法分析、语法分析和语义分析，它通常与目标平台无关，仅负责分析源代码。编译后端包含中间代码生成、优化和目标代码生成，通常与目标平台有关。但是，编译后端并不一定包含中间代码生成和优化两个环节，这取决于具体的场景和实现。中间代码生成和优化这两个环节有时也叫 “中端”。

上图展示了 “教科书” 式的编译模型。但 Vue.js 的模板作为 DSL，其编译流程会有所不同。对于 Vue.js 模板编译器来说，源代码就是组件的模板，而目标代码是能够在浏览器平台上运行的 JavaScript 代码，或其他拥有 JavaScript 运行时的平台代码，如下图所示：

![Vue.js模板编译器的目标代码是JavaScript代码](E:\www\笔记\VueJS-design-and-implementation\imgs\编译器核心\2.png)

可以看到，Vue.js 模板编译器的目标代码其实就是渲染函数。详细而言，Vue.js 模板编译器会首先对模板进行词法分析和语法分析，得到模板 AST。接着，将模板 AST **转换（tranform）**成 JavaScript AST。最后，根据 JavaScript AST 生成 JavaScript 代码，即渲染函数代码。下图给出了 Vue.js 模板编译器的工作流程：

![Vue.js模板编译器的工作流程](E:\www\笔记\VueJS-design-and-implementation\imgs\编译器核心\3.png)

AST 是 abstract syntax tree 的首字母缩写，即抽象语法树。所谓模板 AST，其实就是用来描述模板的抽象语法树。举个例子，假设我们有如下模板：

```html
<div>
  <h1 v-if="ok">
   	Vue Template
  </h1>
</div>
```

这段模板会被编译成如下所示的 AST：

```js
const ast = {
  // 逻辑根节点
  type: 'Root',
  children: [
    // div 标签节点
    {
      type: 'Element',
      tag: 'div',
      children: [
        // h1 标签节点
        {
          type: 'Element',
          tag: 'h1',
          props: [
            // v-if 指令节点
            {
              type: 'Directive', // 类型为 Directive 代表指令
              name: 'if', // 指令名称为 if，不带有前缀 v-
              exp: {
                // 表达式节点
                type: 'Expression',
                content: 'ok'
              }
            }
          ]
        }
      ]
    }
  ]
}
```

可以看到，AST 其实就是一个具有层级结构的对象。模板 AST 具有与模板同构的嵌套结构。每一棵 AST 都有一个逻辑上的根节点，其类型为 Root。模板中真正的根节点则作为 Root 节点的 children 存在。观察上面的 AST，我们可以得出如下结论：

+ 不同类型的节点是通过节点的 type 属性进行区分的。例如标签节点的 type 值为 Element；
+ 标签节点的子节点存储在其 children 数组中；
+ 标签节点的属性节点和指令节点会存储在 props 数组中；
+ 不同类型的节点会使用不同的对象属性进行描述。例如指令节点拥有 name 属性，用来表达指令的名称，而表达式节点拥有 content 属性，用来描述表达式的内容。

我们可以通过封装 `parse()` 函数来完成对模板的词法分析和语法分析，得到模板 AST，如下图所示：

![parse函数的作用](E:\www\笔记\VueJS-design-and-implementation\imgs\编译器核心\4.png)

我们也可以用下面的代码来表达模板解析的过程：

```js
const template = `
  <div>
    <h1 v-if="ok">Vue Template</h1>
  </div>
`

const templateAST = parse(template)
```

可以看到，`parse()` 函数接收字符串模板作为参数，并将解析后得到的 AST 作为返回值返回。

有了模板 AST 后，我们就可以对其进行语义分析，并对模板 AST 进行转换了。什么是语义分析呢？举几个例子：

+ 检查 v-else 指令是否存在相符的 v-if 指令；
+ 分析属性值是否是静态的，是否是常量等；
+ 插槽是否会引用上层作用域的变量；
+ ......

在语义分析的基础上，我们即可得到模板 AST。接着，我们还需要将模板 AST 转换为 JavaScript AST。因为 Vue.js 模板编译器的最终目标是生成渲染函数，而渲染函数本质上是 JavaScript 代码，所以我们需要将模板 AST 转换成用于描述渲染函数的 JavaScript AST。

我们可以封装 `transform()` 函数来完成模板 AST 到 JavaScript AST 的转换工作，如下图所示：

![transform函数的作用](E:\www\笔记\VueJS-design-and-implementation\imgs\编译器核心\5.png)

同样，我们可以用下面的代码来表达：

```js
const templateAST = parse(template)
const jsAST = transform(templateAST)
```

有了 JavaScript AST 之后，我们就可以根据它生成渲染函数了，如下图所示：

![generate函数的作用](E:\www\笔记\VueJS-design-and-implementation\imgs\编译器核心\6.png)

我们也可以用下面的代码来表达代码生成的过程：

```js
const templateAST = parse(template)
const jsAST = transform(templateAST)
const code = generate(jsAST)
```

在上面这段代码中，`generate()` 函数会将渲染函数的代码以字符串的形式返回，并存储在 code 常量中。下图给出完整的流程：

![将Vue.js模板编译为渲染函数的完整流程](E:\www\笔记\VueJS-design-and-implementation\imgs\编译器核心\7.png)

## parser 的实现原理与状态机

上面，我们讲解了 Vue.js 模板编译器的基本结构和工作流程，它主要由三个部分组成：

1. 用来将模板字符串解析为模板 AST 的解析器（parser）；
2. 用来将模板 AST 转换为 JavaScript AST 的转换器（transformer）；
3. 用来根据 JavaScript AST 生成渲染函数代码的生成器（generator）。

接下来，我们将详细讨论解析器 parser 的实现原理。

解析器的入参是字符串模板，解析器会逐个读取字符串中的字符，并根据一定的规则将整个字符串切割为一个个 Token。这里的 Token 可以视作为词法记号，后续我们将使用 Token 一词来代表词法记号进行讲解。举例来说，假设有这样一段模板：

```html
<p>Vue</p>
```

解析器会把这段字符串模板切割为三个 Token：

+ 开始标签：`<p>`；
+ 文本节点：Vue；
+ 结束标签：`</p>`。

那么，解析器是如何对模板进行切割的呢？依据什么规则？这就不得不提到有限状态自动机了。千万不要被这个名词吓到，它理解起来并不难。

所谓 “有限状态”，就是指有限个状态，而 “自动机” 意味着随着字符的输入，解析器会自动地在不同状态间迁移。拿上面的模板来说，当我们分析这段模板字符串时，`parse()` 函数会逐个读取字符，状态机会有一个初始状态，我们记为 “初始状态 1”。下图给出了状态迁移的过程：

![解析器的状态机图](E:\www\笔记\VueJS-design-and-implementation\imgs\编译器核心\8.png)

我们用自然语言来描述上图给出的状态迁移过程：

1. 状态机始于 “初始状态 1”；
2. 在 “初始状态 1” 下，读取模板的第一个字符 `<`，状态机会进入下一个状态，即 “标签开始状态 2”；
3. 在 “标签开始状态 2” 下，读取下一个字符 `p`。由于字符 `p` 是字母，所以状态机会进入 “标签名称状态 3”；
4. 在 “标签名称状态 3” 下，读取下一个字符 `>`，此时状态机会从 “标签名称状态 3” 迁移回 “初始状态 1”，并记录在 “标签名称状态” 下产生的标签名称 `p`；
5. 在 “初始状态 1” 下，读取下一个字符 `V`，此时状态机会进入 “文本状态 4”；
6. 在 “文本状态 4” 下，继续读取后续字符，直到遇到字符 `<` 时，状态机会再次进入 “标签开始状态 2”，并记录在 “文本状态 4” 下产生的文本内容，即字符串 `Vue`；
7. 在 “标签开始状态 2” 下，读取下一个字符 `/`，状态机会进入 “结束标签状态 5”；
8. 在 “结束标签状态 5” 下，读取下一个字符 `p`，状态机会进行 “结束标签名称状态 6”；
9. 在 “结束标签名称状态 6” 下，读取最后一个字符 `>`，它是结束标签的闭合字符，于是状态机迁移回 “初始状态 1”，并记录在 “结束标签名称状态 6” 下生成的结束标签名称。

经过这样一系列的状态移动过程之后，我们最终就能够得到相应的 Token 了。我们观察上图可以发现，有的圆圈是单线的，而有的圆圈是双线的。双线代表此时状态机是一个合法的 Token。

另外，上图给出的状态机并不严谨。实际上，解析 HTML 并构造 Token 的过程是有规范可循的。在 WHATWG 发布的关于浏览器解析 HTML 的规范中，详细阐述了状态迁移。下图截取了该规范中定义在 “初始状态” 下状态机的状态迁移过程：

![Data State](E:\www\笔记\VueJS-design-and-implementation\imgs\编译器核心\9.png)

可以看到，在 “初始状态” （Data State）下，当遇到字符 `<` 时，状态机会迁移到 `tag open state`，即 ”标签开始状态“。如果遇到字符 `<` 以外的字符，规范中也都有对应的说明，应该让状态机迁移到怎样的状态。不如 Vue.js 的模板作为一个 DSL，并非必须遵守该规范。但 Vue.js 的模板毕竟是类 HTML 的实现，因此尽可能按照规范来做，不会有什么坏处。更重要的一点是，规范中已经定义了非常详细的状态迁移过程，这对于我们编写解析器非常有帮助。

按照有限状态自动机的状态迁移过程，我们可以很容易地编写对应的代码实现。因此，有限状态自动机可以帮助我们完成对模板的**标记化（tokenized）**，最终我们将得到一系列 Token。上面图中描述的状态机的实现如下：

```js
// 定义状态机的状态
const State = {
  initial: 1,     // 初始状态
  tagOpen: 2,     // 标签开始状态
  tagName: 3,     // 标签名称状态
  text: 4,        // 文本状态
  tagEnd: 5,      // 结束标签状态
  tagEndName: 6   // 结束标签名称状态
}

// 辅助函数，用于判断是否是字符
const isAlpha = char => char >= 'a' && char <= 'z' || char >= 'A' && char <= 'Z'

// 接收模板字符串作为参数，并将模板切割为 Token 返回
function tokenzie (str) {
  // 状态机的当前状态：初始状态
  let currentState = State.initial
  // 用于缓存字符
  const chars = []
  // 生成的 Token 会存储到 tokens 数组中，并作为函数的返回值返回
  const tokens = []

  // 使用 while 循环开启自动机，只要模板字符串没有被消费完，自动机就会一直运行
  while (str) {
    // 查看第一个字符，注意，这里只是查看，没有消费该字符
    const char = str[0]

    switch (currentState) {
      // 状态机当前处于初始状态
      case State.initial:
        // 遇到字符 '<'
        if (char === '<') {
          // 1. 状态机切换到标签开始状态
          currentState = State.tagOpen
          // 2. 消费字符 '<'
          str = str.slice(1)
        } else if (isAlpha(char)) {
          // 1. 遇到字母，切换到文本状态
          currentState = State.text
          // 2. 将当前字母缓存到 chars 数组
          chars.push(char)
          // 3. 消费当前字符
          str = str.slice(1)
        }
        break
      // 状态机当前处于标签开始状态
      case State.tagOpen:
        if (isAlpha(char)) {
          // 1. 遇到字母，切换到标签名称状态
          currentState = State.tagName
          // 2. 将当前字母缓存到 chars 数组
          chars.push(char)
          // 3. 消费当前字符
          str = str.slice(1)
        } else if (char === '/') {
          // 1. 遇到字符 /，切换到结束标签状态
          currentState = State.tagEnd
          // 2. 消费字符 /
          str = str.slice(1)
        }
        break
      // 状态机当前处于标签名称状态
      case State.tagName:
        if (isAlpha(char)) {
          // 1. 遇到字母，由于当前处理标签名称状态，所以不需要切换状态，
          // 但需要将当前字符缓存到 chars 数组中。
          chars.push(char)
          // 2. 消费当前字符
          str = str.slice(1)
        } else if (char === '>') {
          // 1. 遇到字符 '>'，切换到初始状态
          currentState = State.initial
          // 2. 同时创建一个标签 Token，并添加到 tokens 数组中
          // 注意，此时 chars 中的字符就是标签名称
          tokens.push({
            type: 'tag',
            name: chars.join('')
          })
          // 3. chars 数组的内容已经被消费，清空它
          chars.length = 0
          // 4. 同时消费当前字符 '>'
          str = str.slice(1)
        }
        break
      // 状态机当前处于文本状态
      case State.text:
        if (isAlpha(char)) {
          // 1. 遇到字母，保持状态不变，但应该将当前字符缓存到 chars 数组中
          chars.push(char)
          // 2. 消费当前字符
          str = str.slice(1)
        } else if (char === '<') {
          // 1. 遇到字符 '<'，切换到标签开始状态
          currentState = State.tagOpen
          // 2. 从 文本状态 ---> 标签开始状态，此时应该创建文本 Token，并添加到 tokens 数组中
          // 注意，此时 chars 数组中的字符就是文本内容
          tokens.push({
            type: 'text',
            content: chars.join('')
          })
          // 3. chars 数组的内容已经被消费，清空它
          chars.length = 0
          // 4. 同时消费当前字符 '<'
          str = str.slice(1)
        }
        break
      // 状态机处于标签结束状态
      case State.tagEnd:
        if (isAlpha(char)) {
          // 1. 遇到字母，切换到结束标签名称状态
          currentState = State.tagEndName
          // 2. 将当前字符缓存到 chars 数组中
          chars.push(char)
          // 3. 消费当前字符
          str = str.slice(1)
        }
        break
      // 状态机当前牌结束标签名称状态
      case State.tagEndName:
        if (isAlpha(char)) {
          // 1. 遇到字母，不需要切换状态，但需要将当前字符缓存到 chars 数组中
          chars.push(char)
          // 2. 消费当前字符
          str = str.slice(1)
        } else if (char === '>') {
          // 1. 遇到字符 '>'，切换到初始状态
          currentState = State.initial
          // 2. 从 结束标签名称状态 ---> 初始状态，应该保存结束标签名称 Token
          // 注意，此时 chars 数组中缓存的内容就是标签名称
          tokens.push({
            type: 'tagEnd',
            name: chars.join('')
          })
          // 3. chars 数组的内容已经被消费，清空它
          chars.length = 0
          // 4. 消费当前字符
          str = str.slice(1)
        }
        break
      default:
        break
    }
  }

  // 最后，返回 tokens
  return tokens
}
```

上面这段代码看上去比较冗长，可优化的点非常多。这段代码高度还原了前图展示的状态机，配合代码中的注释会更容易理解。

使用上面给出的 `tokenzie()` 函数来解析模板 `<p>Vue</p>`，我们将得到三个 Token：

```js
const tokens = tokenzie(`<p>Vue</p>`)
console.log(tokens)
// [
//   {
//     "type": "tag",
//     "name": "p"
//   },
//   {
//     "type": "text",
//     "content": "Vue"
//   },
//   {
//     "type": "tagEnd",
//     "name": "p"
//   }
// ]
```

现在，你已经明白了状态机的工作原理，以及模板编译器将模板字符串切割为一个个 Token 的过程。但拿上述例子来说，我们并非总是需要所有 Token。例如，在解析模板的过程中，结束标签 Token 可以省略。这时，我们就可以调整 `tokenzie()` 函数的代码，并选择性地忽略结束标签 Token。当然，有时我们也可能需要更多的 Token，这都取决于具体的需求，然后灵活地调整代码实现。

总而言之，通过有限状态自动机，我们能够将模板解析为一个个 Token，进而可以用它们构建一棵 AST 了。但在具体构建 AST 之前，我们需要思考能否简化 `tokenzie()` 函数的代码？实际上，我们可以通过正则表达式来精简 `tokenzie()` 函数的代码。上文之所以没有从最开始就采用正则表达式来实现，是因为**正则表达式的本质就是有限状态自动机。**当你在编写正则表达式的时候，其实就是在编写有限状态自动机。